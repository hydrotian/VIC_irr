/* Programmer: Andy Wood
   Usage: snowband <soil file> <resolution> <elevation file> <PRISM file> <outfile>   
   Compile with: gcc snowband.c -lm -o snowband

   Purpose: Calculates snow band elevations and fractions for grid cells used in
   VIC, based on a finer resolution DEM, and PRISM precip scalings for precip
   fractions in each snow band.

   The executable takes 6 arguments; user can use an associated script to 
   run it (run_snowband.scr).

   This program reads in lat and long for each VIC cell (e.g., from 
   fields 3 & 4 of the VIC soil file) and a finer resolution elevation file 
   (with arc/info header -- e.g., 30 arcsec DEM) in geographic decimal degree 
   projection which encompasses the entire area.  

   Inputs:   arc-style 30as DEM
             arc-style 30as PRISM annual average values
             VIC soil file info with fmt: <flag><cellnum><lat><lon><vic_elev>
   Output:   VIC-NL snow band elevation file.                 

   The limits of the bands are set such that the fractional areas are
   approximately equal.

   MODIFICATIONS: 
   * Correction to position in DEM file AH 7/28/03 
   * Write one elevation band to cells that have poor fine scale DEM coverage AH 7/28/03 
   * Fold small area fractions into bins at lower elevations to eliminate glaciation AH 7/28/03 
   * Ensure that area fractions add to one AH 7/28/03 
   * Make bands have equal fraction areas, therefore correction to fold in small
     area fractions into bins at lower elevations no longer needed   JA 8/21/03
   * Add precipitation fraction calculations using PRISM annual average values, taken 
     from 30as prism grid generated by AWW:  KA 8/26/03
   * Take out the inactive cell flag and rearrange output format to cell ID, area fract,
     elev fract, precip fract  MM 09/03/2003
   * Add switch between reading/using prism data and not reading/using prism data 
     (e.g. for Mexico) and replace small area fraction check. CM 09/10/2003
   * Minor modifications to clean up code, also stop printing of inactive cells.  AWW-091603

*/

#include <stdio.h>
#include <stdlib.h>

/*the following 2 values should not be changed if running over the US at 1/8th
  degree resolution */
#define MAXNUMBANDS 5   
#define MAXBANDWIDTH 500    //500 meters for US runs
#define MAXSTRING 500
#define MINFRACTION .05  //5 percent

void bubble1(int *sorted, int count, float *precip);
void bubble2(int *sorted, int count);

int main(int argc, char *argv[])
{
  FILE *fo, *fdem, *fm, *fprism;
  char demfile[120], soilfile[120], prismfile[120], outfile[120];
  char tempstr[MAXSTRING];
  int **dem, PRISM_flag;
  float **prism;
  int i,j,m,i_corner, j_corner, columns, rows, ijunk, count_prism;
  float xmin, ymin, size, nodata, nodataP, fjunk;
  int sum, min, max, p ,n, count, numbands, numcells, flag, cellnum;
  float mean[MAXNUMBANDS], fract;
  float resolution, lat, lon, corner_lat, corner_lon;
  int jstart, cellsperband;
  int *sorted;
  float *precip, fprecip[MAXNUMBANDS], sum_precip[MAXNUMBANDS], sum_all_precip;
  float avg_precip_all, avg_precip[MAXNUMBANDS];
  float farea[MAXNUMBANDS];  // vector of fract areas for each pixel in sorted array
  float limits[MAXNUMBANDS],sum_band[MAXNUMBANDS];
  int count_band[MAXNUMBANDS],fmaxindex,ifarea[MAXNUMBANDS], count_all, bandflag;
  int pmaxindex, count_precip[MAXNUMBANDS], count_all_precip;
  float pmax, psum, iprecip[MAXNUMBANDS];
  float vic_elev,fsum, fmax, sum_all, range;

  if(argc != 7) {
    printf("Usage: %s <soil file> <resolution> <elevation file> <PRISM file> <PRISM_flag> <outfile>\n\n",
	   argv[0]); // if PRISM_flag = 1,  the programming reads in prism data. Otherwise not.
    printf("\tsoil file: cols 1-4, 22 from VIC soilparam file;\n");
    printf("\tresolution: (float) resolution of the VIC model run;\n");
    printf("\televation file: DEM with arcinfo header;\n");
    printf("\tPRISM file: gridded PRISM annual averages with arcinfo header;\n");
    printf("\tPRISM flag: if 1, read in PRISM data, otherwise do not;\n");
    printf("\toutfile: the elevation band input file for VIC.\n\n");
    exit(0);
  }

  strcpy(soilfile,argv[1]);
  resolution = atof(argv[2]);
  strcpy(demfile,argv[3]);
  strcpy(prismfile,argv[4]);
  PRISM_flag = atoi(argv[5]);
  strcpy(outfile,argv[6]);
  
  /*--------------------------------------------*/
  /* OPEN FILES                                 */
  /*--------------------------------------------*/

  if((fdem = fopen(demfile,"r")) == NULL) {
    printf("Cannot open/read dem file, %s\n",demfile);
    exit(8); 
  }
  if((fm = fopen(soilfile,"r")) == NULL) {
    printf("Cannot open/read soil file, %s\n",soilfile);
    exit(8); 
  }
  if (PRISM_flag == 1) { 
    if((fprism = fopen(prismfile, "r")) == NULL) {
      printf("Cannot open/read PRISM file, %s\n",prismfile);
      exit(8); 
    }
  }
  if((fo = fopen(outfile, "w")) == NULL) {
    printf("Cannot open/read outfile, %s\n",outfile);
    exit(8); 
  }
  printf("Files successfully opened...\n\n");

  /*--------------------------------------------*/
  /* Scan DEM and PRISM header.                           */
  /*--------------------------------------------*/

  fscanf(fdem,"%s %d",tempstr,&columns);
  fscanf(fdem,"%s %d",tempstr,&rows);
  fscanf(fdem,"%s %f",tempstr,&xmin);
  fscanf(fdem,"%s %f",tempstr,&ymin);
  fscanf(fdem,"%s %f",tempstr,&size);
  fscanf(fdem,"%s %f",tempstr,&nodata);
  printf("%d %d %f %f\n",columns,rows,xmin,ymin);
  numcells = (int)(resolution/size);
  printf("there are %d by %d pixels in each %.3f resolution cell\n",
         numcells, numcells, resolution);

  if (PRISM_flag == 1) { 
    fscanf(fprism,"%s %d",tempstr,&ijunk);
    fscanf(fprism,"%s %d",tempstr,&ijunk);
    fscanf(fprism,"%s %f",tempstr,&fjunk);
    fscanf(fprism,"%s %f",tempstr,&fjunk);
    fscanf(fprism,"%s %f",tempstr,&fjunk);
    fscanf(fprism,"%s %f",tempstr,&nodataP);
  }

  /* ALLOCATE MEMORY TO ARRAYS */
  printf("Allocating memory to arrays...\n");

  if(!(dem = (int**) calloc(rows,sizeof(int*)))) {
    printf("Cannot allocate memory to dem cols\n");
    exit(8); 
  }
  for(i=0; i<rows;i++) {
    if(!(dem[i] = (int*) calloc(columns,sizeof(int)))) {
      printf("Cannot allocate memory to dem rows\n");
      exit(8); 
    }
  }
  if (PRISM_flag == 1) { 
    if(!(prism = (float**) calloc(rows,sizeof(float*)))) {
      printf("Cannot allocate memory to prism cols\n");
      exit(8); 
    }
    for (i=0;i<rows;i++) {
      if(!(prism[i] = (float*) calloc(columns,sizeof(float)))) {
        printf("Cannot allocate memory to prism rows\n");
        exit(8); 
      }
    }
  }
  if(!(sorted = (int*) calloc(numcells*numcells ,sizeof(int)))) {
    printf("Cannot allocate memory for sorted array\n");
    exit(8); 
  }
  if (PRISM_flag == 1) { 
    if(!(precip = (float*) calloc((numcells*numcells),sizeof(float)))) {
      printf("Cannot allocate memory for precip array\n");
      exit(8); 
    }
  }
 
  /*--------------------------------------------*/
  /* READ DEM AND PRISM FILES                   */
  /*--------------------------------------------*/
  printf("Loading DEM data...\n");
  for(i=0; i<rows;i++) {
    for(j=0; j<columns; j++) {
      fscanf(fdem,"%d",&dem[i][j]);
      if(dem[i][j] < 0)     dem[i][j] = nodata;
    }
  }
  fclose(fdem);

  if (PRISM_flag == 1) { 
    printf("Loading PRISM data...\n");
    for (i=0; i<rows; i++) {
      for (j=0; j<columns; j++) {
        fscanf(fprism,"%f",&prism[i][j]);
        if (prism[i][j] < 0)	prism[i][j] = nodataP;
      }
    }
    fclose(fprism);
  }
	
  /*--------------------------------------------*/
  /* GET DATA IN 1 GRID CELL WINDOW             */
  /*--------------------------------------------*/
  printf("Processing cells.\n");
  while(fscanf(fm,"%d%d%f%f%f",
    &flag, &cellnum, &lat, &lon, &vic_elev) != EOF){
    printf("CELL: %d %d %.4f %.4f %.4f\n", flag, cellnum, lat, lon, vic_elev);
    
/*  if (flag != 1) {   #INACTIVE, write null record 
        printf("INACTIVE: \t"); 
       printf("lat = %.4f, lon = %.4f\n",lat,lon); 
       fprintf(fo,"%10d\n",cellnum); 
    } else {   #ACTIVE CELL */

      /* Calculate position in dem file. */
      corner_lat = lat + resolution/2.0;  //upper left
      i_corner = (int)(rows - (corner_lat - ymin)/size); //+1 row for position then -1 for array starts at zero
      corner_lon = lon - resolution/2.0;  //upper left
      j_corner = (int)((corner_lon - xmin)/size);
      printf("ur_lat %.4f i_corner %d ur_lon %.4f j_corner %d\n",
        corner_lat,i_corner, corner_lon, j_corner);
    
      //find max, min, count -- and read into vector for sort
      min = 9999;
      max = -500;
      sum = count = count_prism = 0;
 
      //initialize
      for(i=0;i<numcells*numcells;i++) {
        sorted[i] = 0;
        if (PRISM_flag == 1) precip[i] = 0.0; 
      }

      //get data array for DEM and PRISM values, max, and min
      for(i=i_corner; i<(i_corner+numcells);i++) {
        for(j=j_corner; j<(j_corner+numcells);j++) {
  	      if(dem[i][j] != nodata ) {
            sum += dem[i][j];
            sorted[count] = dem[i][j];
            if(PRISM_flag == 1) {  
              precip[count] = prism[i][j];
	            if (precip[count] < 0.0) count_prism++; 
              /* note count_prism is number of prism nodata (!) in gridcell */
            }
	          count++;  /* num. dem 30as cells in grid cell */
	          if(dem[i][j] < min)   min = dem[i][j];
	          if(dem[i][j] > max)   max = dem[i][j];
          }
        }
      }

      //check for at least 10% coverage by fine res dems
      if (count< (numcells*numcells*0.10)) {  // NO DATA, write null record
        printf("WARNING: Less than 10 percent coverage in VIC cell: \t");
        printf("lat = %.4f, lon = %.4f, count= %d\n",lat,lon,count);
        printf("Writing one elevation band to this cell at mean VIC cell elevation.\n");
        if(flag==1) {
          fprintf(fo,"%10d\t",cellnum);
          for(m=0;m<MAXNUMBANDS;m++){ 
            if(m==0) {
              farea[m]=1.0;  
              mean[m]=vic_elev; 
              fprecip[m]=1.0;
            } else {
              farea[m]=0.0; 
              mean[m]= 0.0; 
              fprecip[m]=0.0;
            } 
            fprintf(fo,"%.3f ",farea[m]);
          }
          fprintf(fo, "\t");
          for (m=0;m<MAXNUMBANDS;m++) 
            fprintf(fo,"%.1f ",mean[m]);
          fprintf(fo, "\t");
          for (m=0;m<MAXNUMBANDS;m++) 
            fprintf(fo,"%.3f ",fprecip[m]);
          fprintf(fo, "\n");
        } 

      } else  {   // DATA IN CELL, proceed w/ analysis ->
	
        range = max-min;

        // sort elevations 
        if (PRISM_flag == 1) bubble1(sorted, count, precip);
        if (PRISM_flag != 1) bubble2(sorted, count);

        // calculate number of bands needed for cell
        numbands = 1;  //default
        bandflag = 0;
        if(range/MAXNUMBANDS > MAXBANDWIDTH) numbands = MAXNUMBANDS;
        else {
          for(i=0;i<MAXNUMBANDS;i++) {
            if((range/(i+1) <= MAXBANDWIDTH) && (bandflag != 1 )){
              bandflag = 1; 
              numbands = i+1;
            }
          }
        }
        printf("elev range = %d: %d to %d\n", max-min,min,max);
        printf("bands = %d\n",numbands );

      	// initialize
        for(i=0;i<MAXNUMBANDS;i++) {
          limits[i] = mean[i] = farea[i] = 0;
          if (PRISM_flag == 1)  avg_precip[i] = fprecip[i] = 0.0; 
        }

        // set band limits 
        cellsperband = (int) count/numbands;  /*find # of pixels per band*/

        for(i=0;i<numbands;i++) {
          limits[i] = sorted[i*cellsperband];
          printf("bandlimit %d = %.1f\n",i+1,limits[i]);
        }
        limits[numbands]=sorted[count-1];
        printf("bandlimit %d = %.1f\n",numbands+1,limits[numbands]);

        // find average elevation and fractional area of each band
        sum_all = sum_all_precip = count_all = count_all_precip = jstart = 0;
	
        for(i=0;i<numbands;i++) {   
          j=jstart;
          sum_band[i] = count_band[i] = sum_precip[i] = count_precip[i] = 0;
	  
          while( j < count && sorted[j] <= limits[i+1] ) {  // go to end of band
            sum_all += sorted[j]; 
            count_all++;
            sum_band[i] += sorted[j];
            count_band[i]++;
            if(PRISM_flag == 1) {
            /* switch: don't calc prec fract for pixels not covered by PRISM */
              if(precip[j] > 0.0) {
                sum_all_precip += precip[j];
                count_all_precip++;
                sum_precip[i] += precip[j];
                count_precip[i]++;
              }
            }
            j++;
          }
          jstart = j;
        }

        if(PRISM_flag == 1) { 	
          /* calc avg PRISM prec values for each band and the whole grid cell */
          avg_precip_all = sum_all_precip/(float)count_all_precip;
          for(i=0; i<numbands; i++) 
            avg_precip[i] = sum_precip[i]/(float)count_precip[i];
        }
 
        /*check to make sure cell avg elev is close to mean VIC elevation*/
       if(count_all != count) 
         printf("ERROR:  cells in computation = %d, cells = %d\n",
           count_all, count); 
	
       if(vic_elev/(sum_all/(float)count) < 0.95 || 
          vic_elev/(sum_all/(float)count) > 1.05) { 
         printf("ERROR: lat= %.4f lon = %.4f vic_elev = %.1f cell_elev = %.1f\n",
           lat,lon,vic_elev,(sum_all/(float)count)); 
       }
	
       /* Check for bins less than MINFRACTION and rearrange from top to bottom */
       for(m= numbands-1;m>0;m--) {
         fract=(float)count_band[m]/(float)count;
         if(fract <= MINFRACTION && count_band[m] > 0.0) {
           count_band[m-1] +=  count_band[m];
           sum_band[m-1] += sum_band[m];
           count_band[m]=0;
           sum_band[m]=0.0;
         }
       }

       /*reallocate bottom bin to closest non-zero bin if below min. fract. threshold*/
       /*Note the routine will only reallocate the bottom bin once*/
       for(p=1;p<numbands;p++){
         if(((float)count_band[0]/(float)count) < MINFRACTION && 
            count_band[0]>0 && count_band[p]>0) {
           count_band[p] += count_band[0];
           sum_band[p] += sum_band[0];
           count_band[0]=0;
           sum_band[0]=0.0;
         }
       }

       /*clean up the arrays so there are no holes after adjustments*/
       for(n=0;n<numbands;n++){
         for(m=0;m<numbands;m++){
           if(count_band[m]==0){
             for(p=m;p<numbands;p++){
               count_band[p] = count_band[p+1];
               sum_band[p]= sum_band[p+1];
             }
             count_band[(int)(numbands - 1)] = 0;
             sum_band[(int)(numbands -1)] = 0;
           }
         }
       }

       /*calculate the area fraction and mean elevation for each band*/
       for(m=0;m<numbands;m++){
         if(count_band[m] != 0){
           farea[m] = (float)count_band[m]/(float)count;
           mean[m] = sum_band[m]/count_band[m];
           if(PRISM_flag == 1) { 
             if(count_prism == count) 
             // if whole cell not covered by PRISM, then prec fract = areal fract
               fprecip[m] = farea[m]; 
             else
               fprecip[m] = sum_precip[m]/sum_all_precip;
           }
         } else {
           farea[m] = 0.0;
           mean[m] = 0.0;
           if (PRISM_flag == 1) fprecip[m] = 0.0;
         }
       }
	
       /* truncate area fractions to three decimal places*/
       for(m=0;m<numbands;m++){ 
         ifarea[m]= (int)(farea[m]*1000);
         farea[m]= (float)(ifarea[m])/1000.0;
         if(PRISM_flag == 1)   iprecip[m] = (int)(fprecip[m]*1000);
         if(PRISM_flag == 1)   fprecip[m] = (float)(iprecip[m])/1000.0;
       }
	
       /*make sure area and precipitation fractions add up exactly to one*/
        fsum= psum=	fmaxindex= pmaxindex=	fmax= pmax=0;
        for(m=0;m<numbands;m++){
          if(farea[m]>fmax) {
            fmax = farea[m]; 
            fmaxindex = m;
          }
          fsum += farea[m];
          if(PRISM_flag == 1) { 
            if(fprecip[m]>pmax) {
              pmax = fprecip[m]; 
              pmaxindex = m;
            }
            psum += fprecip[m];
          }
        }
        farea[fmaxindex] += (1.000-fsum); 
        if (PRISM_flag == 1) fprecip[pmaxindex] += (1.000-psum);
	
        /*--------------------------------------------*/
        /* OUTPUT RESULTS                             */
        /*--------------------------------------------*/
        if(flag==1) {
        fprintf(fo,"%10d\t",cellnum);
	
        /* Output mean elev & fractional area of each band. */
        for (m=0;m<MAXNUMBANDS;m++)   fprintf(fo,"%.3f ",farea[m]);
        fprintf(fo, "\t");
        for (m=0;m<MAXNUMBANDS;m++)   fprintf(fo,"%.1f ",mean[m]);
        fprintf(fo, "\t");

        if(PRISM_flag == 1)
          for (m=0;m<MAXNUMBANDS;m++) fprintf(fo,"%.3f ",fprecip[m]);
        if (PRISM_flag != 1) 
          for (m=0;m<MAXNUMBANDS;m++) fprintf(fo,"%.3f ",farea[m]);
        fprintf(fo, "\n");
        }
    
      } // END OF IF STATEMENT - for if (COUNT > 0)
    // } // END OF IF STATEMENT - for if (FLAG > 0)

  } // END OF WHILE LOOP FOR ACTIVE CELLS

  fclose(fo);
  fclose(fm);

  return 0;
}

/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
/*                         SUBROUTINES                       */
/* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */

void bubble1(int *sorted, int count, float *precip) 
// sort vector of elevations in ascending order, given count;
{
  int temp, i, j;
  float dtemp;

  for(j=0;j<count-1;j++) 
    for(i=0;i<count-1;i++) 
      if(sorted[i] > sorted[i+1]) {
        temp = sorted [i+1];
        sorted[i+1] = sorted[i];
        sorted[i] = temp;
        dtemp = precip[i+1];
        precip[i+1] = precip[i];
        precip[i] = dtemp;
      }
    
}

void bubble2(int *sorted, int count) 
// sort vector of elevations in ascending order, given count;
{
  int temp, i, j;

  for(j=0;j<count-1;j++) 
    for(i=0;i<count-1;i++) 
      if(sorted[i] > sorted[i+1]) {
        temp = sorted [i+1];
        sorted[i+1] = sorted[i];
        sorted[i] = temp;
      }

}
